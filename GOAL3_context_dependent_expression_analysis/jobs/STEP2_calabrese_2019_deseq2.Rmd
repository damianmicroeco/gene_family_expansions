---
title: "Calabrese 2019 Differential Expression"
author: "Damian Hernandez"
date: "7/5/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Preface
The goal of this script is to determine if larger AM-specific orthogroups have higher frequencies of context dependent expression than smaller AM-specific orthogroups. This data is that from Calabrese 2019 which analyzes roots from Populus trichocarpa in the presence of the phosphorus starvation +/- the arbuscular mycorrhizal fungus Rhizophagus irregularis.

The assumed working directory is the jobs folder.

```{r}
library(DESeq2)
library(dplyr)
library(reshape2)
```

## Dataframe management

```{r}
#merge the two experimental dataframes of raw feature counts
featurecounts = read.csv("../raw_data/calabrese_2019/GSE138316_Processed_Populus_preppedforinput.csv", row.names = 1, header = TRUE, sep = "\t")

#sum counts for each transcript to get values for gene
transcript_split = colsplit(row.names(featurecounts), "\\.", c("species", "gene", "transcript"))
featurecounts$gene_id = paste(transcript_split$species, transcript_split$gene, sep = ".")
featurecounts = featurecounts %>%
  group_by(gene_id) %>%
  summarise_all(list(sum))
featurecounts = as.data.frame(featurecounts)
row.names(featurecounts) = featurecounts$gene_id
featurecounts = featurecounts[, -c(1)]

#load metadata
exp_metadata = read.csv("../metadata/calabrese2019_metadata.csv", header = TRUE, row.names = 1)

#put metadata in order of column names from gene counts matrix
all(rownames(exp_metadata) %in% colnames(featurecounts)) #check all samples are in counts
all(rownames(exp_metadata) == colnames(featurecounts)) #check samples are in order
featurecounts = featurecounts[, rownames(exp_metadata)] #put data in same order if the first is true but the second is false

#order factor levels for DESeq to know which is the reference group
exp_metadata$myco = factor(exp_metadata$myco, levels = c("control", "myco"))
exp_metadata$phosphorus = factor(exp_metadata$phosphorus, levels = c("high", "low"))

#load in orthogroup statistics to identify am-specific orthogroups
ortho = read.csv("../metadata/orthogroup_mannwhitney.csv", header = TRUE)
am_ortho = ortho[(ortho$mann_FDR <= 0.05) & (ortho$am_v_nm) > 1,]
```

## DESeq2

```{r warning = FALSE}
#load data in to DESeq object
dds = DESeqDataSetFromMatrix(countData = featurecounts,
                                 colData = exp_metadata,
                                 design = ~myco*phosphorus
                                 )

#remove low count reads (optional, but I'm doing it)
keep = rowSums(counts(dds)) >= 10
dds = dds[keep,]

#perform differential expression analysis
dds_analysis = DESeq(dds, test = "LRT", reduced = ~1)
results = results(dds_analysis, alpha = 0.05)
int_analysis = DESeq(dds, test = "LRT", reduced = ~myco+phosphorus)
int_results = results(int_analysis, alpha = 0.05)

#load in genome metadata
#note: there are duplicates because there are multiple isoforms for each gene in the genome metadata.
#fix by getting isoform with lowest e-value
gen_data = read.table("../processed_data/20210718_populus_blast_with_orthogroup.tsv", 
                      sep = "\t", header = TRUE, comment.char = "", quote = "") #tell it to ignore the #
gen_data = gen_data[order(gen_data$gene_stable_id, gen_data$evalue, decreasing = FALSE),] #sort by populus gene_stable_id to group genes together and then by evalue

gen_unique <- gen_data[!duplicated(gen_data$gene_stable_id),]

#remove plastid genes
med_ortho = read.csv("../metadata/orthogroup_identified_AM_medicago_truncatula_genome_metadata.tsv", sep = "\t")
plastid = med_ortho[med_ortho$X.Replicon.Name == "Pltd",]
gen_unique = gen_unique[!(gen_unique$orthogroup %in% plastid$Orthogroup),]

#merge the rlog data with the genomic metadata
#note: some rna-seq reads aren't in the genomic metadata
#note2: I checked a random set of 10 and these genes don't have protein products because they're either pseudo-genes or non-coding RNA
int_results_df = as.data.frame(int_results)
int_composite = merge(int_results_df, gen_unique, by.x = 0, by.y = "gene_stable_id")
int_composite$de_sig = int_composite$padj <= .05
int_composite$de_sig[is.na(int_composite$de_sig)] = FALSE

#get gene counts per orthogroup in refseq
gene_counts = gen_unique %>% 
                group_by(orthogroup) %>%
                dplyr::summarise(count = n())

am_gene_counts = gene_counts[gene_counts$orthogroup %in% am_ortho$X,]

#filter for results only in am-specific orthogroups
am_int = int_composite[int_composite$orthogroup %in% am_ortho$X,]

#add gene count info to am_int
am_int = merge(am_int, am_gene_counts, by = "orthogroup")

#add boolean column for whether genes were differentially expressed.
#used to calculate frequencies
am_int$de_sig = am_int$padj <= 0.05
am_int$de_sig[is.na(am_int$de_sig)] = FALSE

#summarise relationship between am-specific orthogroup size and significance
#mean is used on the count column because this is just duplicated for each orthogroup value
am_summary = am_int %>%
  group_by(orthogroup) %>%
  dplyr::summarise(de_count = sum(de_sig), freq = sum(de_sig)/mean(count), gene_count = mean(count))

#repeat summarization for full dataset to perform permutational analyses
int_composite = merge(int_composite, gene_counts, by = "orthogroup")
int_summary = int_composite %>%
  group_by(orthogroup) %>%
  dplyr::summarise(de_count = sum(de_sig), freq = sum(de_sig)/mean(count), gene_count = mean(count))

#Plot distributions of gene counts and frequencies in both summarizations to determine if parametric tests are appropriate or if permutational tests must be used
#AM DE Frequencies
hist(am_summary$freq)

#AM Gene Counts
hist(am_summary$gene_count)

#Complete dataset DE Frequencies
hist(int_summary$freq)

#Complete dataset Gene Counts
hist(int_summary$gene_count)

#All distributions are heavily skewed. So, parametric tests are not appropriate. Instead, perform permutations from observed distributions to determine if AM relationship is stronger than that observed in complete dataset. Perform permutations to observed if strength of AM relationship is stronger than random.

#observed relationship between am-specific orthogroup size and frequency of significant interactive expression
(freq_v_gen = cor.test(am_summary$freq, am_summary$gene_count, method = "spearman"))

#Is strength of AM relationship greater than expected from the complete dataset?
perm_rho = rep(0, 10000)
for (i in 1:10000) {
  random_df = int_summary[sample(1:nrow(int_summary), length(am_summary$orthogroup)),]
  holder = cor.test(random_df$freq, random_df$gene_count, method = "spearman")
  perm_rho[i] = holder$estimate[[1]]
}
perm_rho[is.na(perm_rho)] = 0 #some values may be NA. convert to zero which means no relationship.
dens = density(perm_rho) 
plot(dens, xlim = c(-.5, .5), main = "Is strength of AM relationship greater than expected from the complete dataset?", xlab = "Spearman rho", 
     frame = FALSE)
polygon(dens, col = "steelblue")
abline(v = freq_v_gen$estimate[[1]], col = "black", lwd = 3, lty = 2)

(pvalue = sum(abs(freq_v_gen$estimate[[1]]) <= abs(perm_rho))/length(perm_rho))

#save this to dataframe for comparing all experiments later.
df_to_save = data.frame(perm_rho, rep(freq_v_gen$estimate, length(perm_rho)), rep("calabrese2019_root", length(perm_rho)))
colnames(df_to_save) = c("permuted_rho", "observed_rho", "data_source")
write.csv(df_to_save, "../processed_data/transcriptome_relationships/calabrese2019_root.csv")

#Is strength of AM relationship greater than random?
perm_rho = rep(0, 10000)
for (i in 1:10000) {
  random_count = sample(am_summary$gene_count)
  holder = cor.test(am_summary$freq, random_count, method = "spearman")
  perm_rho[i] = holder$estimate[[1]]
}
dens = density(perm_rho)
plot(dens, xlim = c(-.5, .5), main = "Randomized significant interaction frequencies", xlab = "Spearman rho", 
     frame = FALSE)
polygon(dens, col = "steelblue")
abline(v = freq_v_gen$estimate[[1]], col = "black", lwd = 3, lty = 2)

(pvalue = sum(abs(freq_v_gen$estimate[[1]]) <= abs(perm_rho))/length(perm_rho))
```
