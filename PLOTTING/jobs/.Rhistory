km = kmeans(kplot, centers = i, nstart = 100)
wss[i] = km$tot.withinss
}
plot(wss)
#the elbow looks to occur at 5-6 clusters. Visual assessment of the plots suggest 6 clusters is a little clearer than 5.
fviz_cluster(kmeans(kplot, centers = 5, nstart = 100), data = kplot, ellipse.type = "confidence", ellipse.alpha = .5, labelsize = NA)
fviz_cluster(kmeans(kplot, centers = 6, nstart = 100), data = kplot, ellipse.type = "confidence", ellipse.alpha = .5, labelsize = NA)
ha = HeatmapAnnotation(myco = substr(colnames(plot_wide), 1, 2), col = list(myco = c("AM" = "#62C1F7", "NM" = "#c3e7fc")))
hb = rowAnnotation(ortho_size = anno_lines(rowMeans(sig_df[sig_df$X %in% row.names(plot_wide),2:43])))
col_fun = colorRamp2(c(0, 1), c("white", "#f79862"))
col_labels = substr(colnames(plot_wide), 11, nchar(colnames(plot_wide)))
col_labels = gsub("_", " ", col_labels)
col_labels = str_to_sentence(col_labels)
(modheat_fix = Heatmap(as.matrix(plot_wide), top_annotation = ha, right_annotation = hb, col = col_fun,
clustering_distance_columns = "euclidean", clustering_distance_rows = "euclidean",
clustering_method_columns = "ward.D2", clustering_method_rows = "ward.D2",
column_split = substr(colnames(plot_wide), 1, 2),
column_labels = col_labels,
row_labels = sig_df$X,
show_row_names = FALSE,
column_names_gp = gpar(fontface = "italic", fontsize = 8),
row_km = 6, row_km_repeats = 100
)
)
#extract orthogroup clusters from k-means clustering to see relationships in PCA if possible
ortho_clusters = row_order(modheat_fix)
clust_id = c()
clust_point = c()
count = 1
for (i in ortho_clusters) {
clust_id = append(clust_id, rep(names(ortho_clusters[count]), length(i)))
clust_point = append(clust_point, i)
count = count + 1
}
#clust_df = data.frame(clust_id = clust_id, clust_point = clust_point) #I'm commenting this out because the k-means clustering will vary a little between runs and I don't want to give stats for a specific grouping and then it vary somewhat every time I run the script. The qualitative outcome is always the same.
clust_df = clust_df[order(clust_df$clust_point),]
clust_df$ortho = sig_df[sig_df$X %in% row.names(plot_wide),]$X
ortho_pca = prcomp(plot_wide, scale. = TRUE)
ggbiplot(ortho_pca, alpha = 0, groups = as.factor(clust_df$clust_id), varname.size = 3, ellipse = TRUE) +
geom_point(aes(color = groups), size = rowMeans(sig_df[sig_df$X %in% row.names(plot_wide),2:43]), alpha = .4) +
theme_classic()
ha = HeatmapAnnotation(myco = substr(colnames(plot_wide), 1, 2), col = list(myco = c("AM" = "#62C1F7", "NM" = "#c3e7fc")), simple_anno_size = unit(.2, "cm"), show_annotation_name = FALSE)
hb = rowAnnotation(ortho_size = anno_lines(rowMeans(sig_df[sig_df$X %in% row.names(plot_wide),2:43])), show_annotation_name = FALSE)
hc = rowAnnotation(clust = as.factor(clust_df$clust_id), show_annotation_name = FALSE)
col_fun = colorRamp2(c(0, 1), c("white", "#f79862"))
col_labels = substr(colnames(plot_wide), 11, nchar(colnames(plot_wide)))
col_labels = gsub("_", " ", col_labels)
col_labels = str_to_sentence(col_labels)
#svg("../base_plots/20231205_AMvNM_Heatmap_noplastid.svg", width = 5, height = 5, pointsize = 7)
Heatmap(as.matrix(plot_wide), top_annotation = ha, right_annotation = hb, left_annotation = hc, col = col_fun,
clustering_distance_columns = "euclidean",
clustering_method_columns = "ward.D2",
cluster_rows = FALSE,
column_split = substr(colnames(plot_wide), 1, 2),
row_split = clust_df$clust_id,
column_labels = col_labels,
show_row_names = FALSE,
column_names_gp = gpar(fontface = "italic", fontsize = 8)
)
#dev.off()
#write.csv(clust_df, "../intermediate_data/20220517_heatmap_clustering_noplastid.csv", row.names = FALSE)
#clust_df = read.csv("../intermediate_data/20220517_heatmap_clustering_noplastid.csv")
### ORTHOGROUP BIOLOGY ###
med_ortho = read.csv("../../am_ortho/metadata/orthogroup_identified_AM_medicago_truncatula_genome_metadata.tsv", sep = "\t")
#cluster 1 (strong difference btw AM and NM and consistency in AM plants)
clust1 = clust_df[clust_df$clust_id == 1,]
med1 = med_ortho[med_ortho$Orthogroup %in% clust1$ortho,]
#cluster 2 and 3 (Poaceae differences)
clust2 = clust_df[clust_df$clust_id == 2,]
med2 = med_ortho[med_ortho$Orthogroup %in% clust2$ortho,]
clust3 = clust_df[clust_df$clust_id == 3,]
med3 = med_ortho[med_ortho$Orthogroup %in% clust3$ortho,]
#cluster 4 and 5 (strong differences between AM and NM, but more Brass driven)
clust4 = clust_df[clust_df$clust_id == 4,]
med4 = med_ortho[med_ortho$Orthogroup %in% clust4$ortho,]
clust5 = clust_df[clust_df$clust_id == 5,]
med5 = med_ortho[med_ortho$Orthogroup %in% clust5$ortho,]
#cluster 6 (strong difference btw AM and NM and consistency in AM plants)
clust6 = clust_df[clust_df$clust_id == 6,]
med6 = med_ortho[med_ortho$Orthogroup %in% clust6$ortho,]
#convert to long form for statistics
poaceae = c("AM_refseq_aegilops_tauschii", "AM_refseq_brachypodium_distachyon", "AM_refseq_setaria_italica", "AM_refseq_sorghum_bicolor", "AM_refseq_zea_mays")
stats_df_prep = function(df) {
df_long = gather(df, species, ortho_size)
df_long$myco = substr(df_long$species, 1, 2)
df_long$poaceae = ifelse(df_long$species %in% poaceae, "poaceae", "not_poaceae")
return(df_long)
}
size1 = stats_df_prep(plot_wide[row.names(plot_wide) %in% clust1$ortho,])
size2 = stats_df_prep(plot_wide[row.names(plot_wide) %in% clust2$ortho,])
size3 = stats_df_prep(plot_wide[row.names(plot_wide) %in% clust3$ortho,])
size4 = stats_df_prep(plot_wide[row.names(plot_wide) %in% clust4$ortho,])
size5 = stats_df_prep(plot_wide[row.names(plot_wide) %in% clust5$ortho,])
size6 = stats_df_prep(plot_wide[row.names(plot_wide) %in% clust6$ortho,])
#AM v NM comparison
p_vals = rep(0, 6)
w_vals = rep(0, 6)
p_vals[1] = wilcox.test(ortho_size ~ myco, data = size1)$p.value
p_vals[2] = wilcox.test(ortho_size ~ myco, data = size2)$p.value
p_vals[3] = wilcox.test(ortho_size ~ myco, data = size3)$p.value
p_vals[4] = wilcox.test(ortho_size ~ myco, data = size4)$p.value
p_vals[5] = wilcox.test(ortho_size ~ myco, data = size5)$p.value
p_vals[6] = wilcox.test(ortho_size ~ myco, data = size6)$p.value
w_vals[1] = wilcox.test(ortho_size ~ myco, data = size1)$statistic
w_vals[2] = wilcox.test(ortho_size ~ myco, data = size2)$statistic
w_vals[3] = wilcox.test(ortho_size ~ myco, data = size3)$statistic
w_vals[4] = wilcox.test(ortho_size ~ myco, data = size4)$statistic
w_vals[5] = wilcox.test(ortho_size ~ myco, data = size5)$statistic
w_vals[6] = wilcox.test(ortho_size ~ myco, data = size6)$statistic
(q_vals = p.adjust(p_vals, method = "fdr"))
w_vals
#poaceae comparisons
poaceae_df_prep = function(df) {
df_prep = df[df$myco == "AM",]
return(df_prep)
}
po1 = poaceae_df_prep(size1)
po2 = poaceae_df_prep(size2)
po3 = poaceae_df_prep(size3)
po4 = poaceae_df_prep(size4)
po5 = poaceae_df_prep(size5)
po6 = poaceae_df_prep(size6)
p_vals = rep(0, 6)
w_vals = rep(0, 6)
p_vals[1] = wilcox.test(ortho_size ~ poaceae, data = po1)$p.value
p_vals[2] = wilcox.test(ortho_size ~ poaceae, data = po2)$p.value
p_vals[3] = wilcox.test(ortho_size ~ poaceae, data = po3)$p.value
p_vals[4] = wilcox.test(ortho_size ~ poaceae, data = po4)$p.value
p_vals[5] = wilcox.test(ortho_size ~ poaceae, data = po5)$p.value
p_vals[6] = wilcox.test(ortho_size ~ poaceae, data = po6)$p.value
w_vals[1] = wilcox.test(ortho_size ~ poaceae, data = po1)$statistic
w_vals[2] = wilcox.test(ortho_size ~ poaceae, data = po2)$statistic
w_vals[3] = wilcox.test(ortho_size ~ poaceae, data = po3)$statistic
w_vals[4] = wilcox.test(ortho_size ~ poaceae, data = po4)$statistic
w_vals[5] = wilcox.test(ortho_size ~ poaceae, data = po5)$statistic
w_vals[6] = wilcox.test(ortho_size ~ poaceae, data = po6)$statistic
(q_vals = p.adjust(p_vals, method = "fdr"))
w_vals
View(po1)
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(ggplot2)
library(tidyr)
library(ComplexHeatmap)
library(devtools)
install_github("jokergoo/ComplexHeatmap")
library(ComplexHeatmap)
#load in iris data. for you this would be reading in your dataframe
data(iris)
force(iris)
View(iris)
#load in iris data. for you this would be reading in your dataframe
data(iris)
force(iris)
#this is just formatting of the iris dataset to make it look more like your expected dataframe. You can ignore this. We're making species the column names and measurements the rownames.
str(iris)
#this is just formatting of the iris dataset to make it look more like your expected dataframe.
df = iris[,1:4]
View(df)
?kmeans
##determine ideal number of k clusters for rows and columns. we scale to make the measurements comparable with each other.
#rows
wss = rep(0, 20)
for (i in 1:(length(wss))) {
km = kmeans(scale(df), centers = i, nstart = 100)
wss[i] = km$tot.withinss
}
plot(wss)
?kmeans
View(km)
plot(km)
unique(iris$Species)
#"species", the individuals. We expect 3 to be the optimal cluster value because there are 3 actual species in the iris data
wss = rep(0, 20)
for (i in 1:(length(wss))) {
km = kmeans(scale(t(df)), centers = i, nstart = 100)
wss[i] = km$tot.withinss
}
for (i in 1:(length(wss))) {
km = kmeans(scale(as.data.frame(t(df))), centers = i, nstart = 100)
wss[i] = km$tot.withinss
}
#measurements. there's only 4 measurements, so I'm capping it at 4 here otherwise you get an error, but it should be 20 in your case
wss = rep(0, 4)
for (i in 1:(length(wss))) {
km = kmeans(scale(as.data.frame(t(df))), centers = i, nstart = 100)
wss[i] = km$tot.withinss
}
#measurements. there's only 4 measurements, so I'm capping it at 4 here otherwise you get an error, but it should be 20 in your case
wss = rep(0, 4)
for (i in 1:(length(wss))) {
km = kmeans(scale(as.data.frame(t(df))), centers = i, nstart = 100)
wss[i] = km$tot.withinss
}
#measurements. there's only 4 measurements, so I'm capping it at 3 here otherwise you get an error, but it should be 20 in your case
wss = rep(0, 3)
for (i in 1:(length(wss))) {
km = kmeans(scale(as.data.frame(t(df))), centers = i, nstart = 100)
wss[i] = km$tot.withinss
}
plot(wss)
##determine ideal number of k clusters for rows and columns. we scale to make the measurements comparable with each other.
#"species", the individuals. We expect 3 to be the optimal cluster value because there are 3 actual species in the iris data
wss = rep(0, 20)
for (i in 1:(length(wss))) {
km = kmeans(scale(df), centers = i, nstart = 100)
wss[i] = km$tot.withinss
}
plot(wss)
#measurements. there's only 4 measurements, so I'm capping it at 3 here otherwise you get an error, but it should be 20 in your case
wss = rep(0, 3)
for (i in 1:(length(wss))) {
km = kmeans(scale(as.data.frame(t(df))), centers = i, nstart = 100)
wss[i] = km$tot.withinss
}
plot(wss)
#save optimal k values to variables
spec_k = 3 #optimal species k
gf_k = 2 #optimal gene family k
#create heatmap to do the hierarchical clustering with the specified number of k-clusters
(modheat = Heatmap(as.matrix(df),
clustering_distance_columns = "euclidean", clustering_distance_rows = "euclidean",
clustering_method_columns = "ward.D2", clustering_method_rows = "ward.D2",
show_row_names = FALSE,
column_names_gp = gpar(fontface = "italic", fontsize = 8),
row_km = spec_k, row_km_repeats = 100, #here rows are species, your dataframe may have them as columns
col_km = gf_k, col_km_repeats = 100 #here columns are gene families, your dataframe may have them as rows
)
)
?Heatmap
#create heatmap to do the hierarchical clustering with the specified number of k-clusters
(modheat = Heatmap(as.matrix(df),
clustering_distance_columns = "euclidean", clustering_distance_rows = "euclidean",
clustering_method_columns = "ward.D2", clustering_method_rows = "ward.D2",
show_row_names = FALSE,
column_names_gp = gpar(fontface = "italic", fontsize = 8),
row_km = spec_k, row_km_repeats = 100, #here rows are species, your dataframe may have them as columns
column_km = gf_k, column_km_repeats = 100 #here columns are gene families, your dataframe may have them as rows
)
)
#extract k-cluster identity
row_clusters = row_order(modheat)
#extract k-cluster identity
modheat = draw(modheat)
row_clusters = row_order(modheat)
#create heatmap to do the hierarchical clustering with the specified number of k-clusters
(modheat = Heatmap(as.matrix(df),
clustering_distance_columns = "euclidean", clustering_distance_rows = "euclidean",
clustering_method_columns = "ward.D2", clustering_method_rows = "ward.D2",
show_row_names = FALSE,
column_names_gp = gpar(fontface = "italic", fontsize = 8),
row_km = spec_k, row_km_repeats = 100, #here rows are species, your dataframe may have them as columns
column_km = gf_k, column_km_repeats = 100 #here columns are gene families, your dataframe may have them as rows
)
)
#extract k-cluster identity
modheat = draw(modheat)
row_clusters = row_order(modheat)
row_clustid = c()
#extract k-cluster identity. we'll only do this for rows for now because that's probably what you're most interested. but you can do the same idea for columns
modheat = draw(modheat)
row_clusters = row_order(modheat)
row_clustid = c()
row_point = c()
count = 1
for (i in row_clusters) {
row_clustid = append(row_clustid, rep(names(row_clusters[count]), length(i)))
row_point = append(wor_point, i)
count = count + 1
}
row_clusters = row_order(modheat)
row_clustid = c()
row_point = c()
count = 1
for (i in row_clusters) {
row_clustid = append(row_clustid, rep(names(row_clusters[count]), length(i)))
row_point = append(row_point, i)
count = count + 1
}
#store cluster identity in a dataframe
clust_df = data.frame(
row_clustid,
row_point
)
View(clust_df)
View(clust_df)
View(row_clusters)
row_clusters
View(clust_df)
#store cluster identity in a dataframe
clust_df = data.frame(
row_clustid,
row_point
)
View(clust_df)
clust_df = clust_df[order(clust_df$row_point),]
View(clust_df)
clust_df$species = row.names(df)
View(clust_df)
#don't run this for your data, this is just a sanity check on my end to confirm I did the clustering correctly
clust_df$iris_species = iris$Species
pca_res = prcomp(df, scale. = TRUE)
library(ggbiplot)
ggbiplot(pca_res, groups = as.factor(clust_df$row_clustid), varname.size = 3, ellipse = TRUE) +
geom_point(aes(color = groups, shape = clust_df$iris_species), alpha = .4) + #the shape is for checking the clustering makes sense, you don't need it
theme_classic()
ggbiplot(pca_res, alpha = 0, groups = as.factor(clust_df$row_clustid), varname.size = 3, ellipse = TRUE) +
geom_point(aes(color = groups, shape = clust_df$iris_species), alpha = .4) + #the shape is for checking the clustering makes sense, you don't need it
theme_classic()
##Proper Heatmap Drawing
#cluster identity of rows
hc = rowAnnotation(clust = as.factor(clust_df$row_clustid), show_annotation_name = FALSE)
#colormap
col_fun = colorRamp2(c(0, 1), c("white", "#f79862"))
??colorRamp
library(circlize)
#colormap
col_fun = colorRamp2(c(0, 1), c("white", "#f79862"))
##Proper Heatmap Drawing
#cluster identity of rows. don't do the species kwarg because that's just to confirm the k-means results make sense. it should based on the biplot, but just a sanity check
hc = rowAnnotation(clust = as.factor(clust_df$row_clustid), species = clust_df$iris_species, show_annotation_name = FALSE)
Heatmap(as.matrix(plot_wide), left_annotation = hc, col = col_fun,
clustering_distance_columns = "euclidean",
clustering_method_columns = "ward.D2",
cluster_rows = FALSE,
row_split = clust_df$clust_id,
show_row_names = FALSE,
column_names_gp = gpar(fontface = "italic", fontsize = 8)
)
Heatmap(as.matrix(df), left_annotation = hc, col = col_fun,
clustering_distance_columns = "euclidean",
clustering_method_columns = "ward.D2",
cluster_rows = FALSE,
row_split = clust_df$clust_id,
show_row_names = FALSE,
column_names_gp = gpar(fontface = "italic", fontsize = 8)
)
Heatmap(as.matrix(scale(df)), left_annotation = hc, col = col_fun,
clustering_distance_columns = "euclidean",
clustering_method_columns = "ward.D2",
cluster_rows = FALSE,
row_split = clust_df$clust_id,
show_row_names = FALSE,
column_names_gp = gpar(fontface = "italic", fontsize = 8)
)
##Proper Heatmap Drawing
#cluster identity of rows. don't do the species kwarg because that's just to confirm the k-means results make sense. it should based on the biplot, but just a sanity check
hc = rowAnnotation(clust = as.factor(clust_df$row_clustid), show_annotation_name = FALSE)
#colormap
col_fun = colorRamp2(c(0, 1), c("white", "#f79862"))
Heatmap(as.matrix(scale(df)), left_annotation = hc, col = col_fun,
clustering_distance_columns = "euclidean",
clustering_method_columns = "ward.D2",
cluster_rows = FALSE,
row_split = clust_df$clust_id,
show_row_names = FALSE,
column_names_gp = gpar(fontface = "italic", fontsize = 8)
)
View(clust_df)
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(ggplot2)
library(tidyr)
library(ComplexHeatmap)
library(ggbiplot)
library(circlize)
#load in iris data. for you this would be reading in your dataframe
data(iris)
force(iris)
#this is just formatting of the iris dataset to make it look more like your expected dataframe.
df = iris[,1:4]
##determine ideal number of k clusters for rows and columns. we scale to make the measurements comparable with each other.
#"species", the individuals. We expect 3 to be the optimal cluster value because there are 3 actual species in the iris data
wss = rep(0, 20)
for (i in 1:(length(wss))) {
km = kmeans(scale(df), centers = i, nstart = 100)
wss[i] = km$tot.withinss
}
plot(wss)
#Post-analysis note: around 3 is the lowest total within sums of squares before it starts to plateau. This makes sense since we expect 3 species.
#measurements. there's only 4 measurements, so I'm capping it at 3 here otherwise you get an error, but it should be 20 in your case
wss = rep(0, 3)
for (i in 1:(length(wss))) {
km = kmeans(scale(as.data.frame(t(df))), centers = i, nstart = 100)
wss[i] = km$tot.withinss
}
plot(wss)
#Post-analysis note: for the sake of plotting we'll use 2 as the k, but it has nothing to do with biology because there's just not enough measurements for k-means to be worthwhile.
#save optimal k values to variables
spec_k = 3 #optimal species k
gf_k = 2 #optimal gene family k
#create heatmap to do the hierarchical clustering with the specified number of k-clusters
(modheat = Heatmap(as.matrix(df),
clustering_distance_columns = "euclidean", clustering_distance_rows = "euclidean",
clustering_method_columns = "ward.D2", clustering_method_rows = "ward.D2",
show_row_names = FALSE,
column_names_gp = gpar(fontface = "italic", fontsize = 8),
row_km = spec_k, row_km_repeats = 100, #here rows are species, your dataframe may have them as columns
column_km = gf_k, column_km_repeats = 100 #here columns are gene families, your dataframe may have them as rows
)
)
#extract k-cluster identity. we'll only do this for rows for now because that's probably what you're most interested. but you can do the same idea for columns
modheat = draw(modheat)
row_clusters = row_order(modheat)
row_clustid = c() #k-means cluster identity
row_point = c() #row number from original dataframe
count = 1
for (i in row_clusters) {
row_clustid = append(row_clustid, rep(names(row_clusters[count]), length(i)))
row_point = append(row_point, i)
count = count + 1
}
#store cluster identity in a dataframe
clust_df = data.frame(
row_clustid,
row_point
)
clust_df = clust_df[order(clust_df$row_point),] #match order of original dataframe
clust_df$species = row.names(df) #this will be the same as in row_point in this dataset because we didn't have real rownames in the iris dataset. for you, your rows might be gene families, so you can just change the name
#don't run this for your data, this is just a sanity check on my end to confirm I did the clustering correctly
clust_df$iris_species = iris$Species
#pca plotting for sanity checks. do the vibes fit (for your analysis) and does it match the iris expectation (code checking for me)
pca_res = prcomp(df, scale. = TRUE)
ggbiplot(pca_res, alpha = 0, groups = as.factor(clust_df$row_clustid), varname.size = 3, ellipse = TRUE) +
geom_point(aes(color = groups, shape = clust_df$iris_species), alpha = .4) + #the shape is for checking the clustering makes sense, you don't need it
theme_classic()
#Post-analysis notes: some individuals get mislabeled between versicolor and virginica, but it's very few. K-means clustering makes sense.
##Proper Heatmap Drawing
#cluster identity of rows. don't do the species kwarg because that's just to confirm the k-means results make sense. it should based on the biplot, but just a sanity check
hc = rowAnnotation(clust = as.factor(clust_df$row_clustid), show_annotation_name = FALSE)
#colormap
col_fun = colorRamp2(c(0, 1), c("white", "#f79862"))
Heatmap(as.matrix(scale(df)), left_annotation = hc, col = col_fun,
clustering_distance_columns = "euclidean",
clustering_method_columns = "ward.D2",
cluster_rows = FALSE,
row_split = clust_df$clust_id,
show_row_names = FALSE,
column_names_gp = gpar(fontface = "italic", fontsize = 8)
)
?Heatmap
Heatmap(as.matrix(scale(df)), left_annotation = hc, col = col_fun,
#clustering_distance_columns = "euclidean",
#clustering_method_columns = "ward.D2",
cluster_rows = FALSE,
row_split = clust_df$clust_id,
show_row_names = FALSE,
column_names_gp = gpar(fontface = "italic", fontsize = 8)
)
Heatmap(as.matrix(scale(df)), left_annotation = hc, col = col_fun,
#clustering_distance_columns = "euclidean",
#clustering_method_columns = "ward.D2",
cluster_rows = FALSE,
row_split = as.factor(clust_df$clust_id),
show_row_names = FALSE,
column_names_gp = gpar(fontface = "italic", fontsize = 8)
)
Heatmap(as.matrix(scale(df)), left_annotation = hc, col = col_fun,
#clustering_distance_columns = "euclidean",
#clustering_method_columns = "ward.D2",
cluster_rows = FALSE,
row_split = as.factor(clust_df$clust_id),
show_row_names = FALSE,
column_names_gp = gpar(fontface = "italic", fontsize = 8)
)
Heatmap(as.matrix(scale(df)), left_annotation = hc, col = col_fun,
#clustering_distance_columns = "euclidean",
#clustering_method_columns = "ward.D2",
cluster_rows = FALSE,
row_split = clust_df$clust_id,
show_row_names = FALSE,
column_names_gp = gpar(fontface = "italic", fontsize = 8)
)
Heatmap(as.matrix(scale(df)), left_annotation = hc, col = col_fun,
#clustering_distance_columns = "euclidean",
#clustering_method_columns = "ward.D2",
cluster_rows = FALSE,
row_split = clust_df$row_clustid,
show_row_names = FALSE,
column_names_gp = gpar(fontface = "italic", fontsize = 8)
)
##Proper Heatmap Drawing
#cluster identity of rows. don't do the species kwarg because that's just to confirm the k-means results make sense. it should based on the biplot, but just a sanity check
hc = rowAnnotation(clust = as.factor(clust_df$row_clustid), species = clust_df$iris_species, show_annotation_name = FALSE)
#colormap
col_fun = colorRamp2(c(0, 1), c("white", "#f79862"))
Heatmap(as.matrix(scale(df)), left_annotation = hc, col = col_fun,
#clustering_distance_columns = "euclidean",
#clustering_method_columns = "ward.D2",
cluster_rows = FALSE,
row_split = clust_df$row_clustid,
show_row_names = FALSE,
column_names_gp = gpar(fontface = "italic", fontsize = 8)
)
Heatmap(as.matrix(scale(df)), left_annotation = hc, col = col_fun,
clustering_distance_columns = "euclidean",
clustering_method_columns = "ward.D2",
cluster_rows = FALSE,
row_split = clust_df$row_clustid,
show_row_names = FALSE,
column_names_gp = gpar(fontface = "italic", fontsize = 8)
)
#colormap
col_fun = colorRamp2(c(0, max(df)), c("white", "#f79862"))
Heatmap(as.matrix(df), left_annotation = hc, col = col_fun,
clustering_distance_columns = "euclidean",
clustering_method_columns = "ward.D2",
cluster_rows = FALSE,
row_split = clust_df$row_clustid,
show_row_names = FALSE,
column_names_gp = gpar(fontface = "italic", fontsize = 8)
)
